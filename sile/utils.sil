% Bulletless lists with customizable spacing between items.
% Usage: \itemize[itemsep=0.35em]{ \item{First} \item{Second} }
% If itemsep is omitted, a default compact spacing is used.
\lua{
  if not SILE.scratch then SILE.scratch = {} end
  SILE.scratch.hr_list = SILE.scratch.hr_list or { itemsep_default = "0.35em" }

  local function _hr_noindent()
    SILE.settings:set("current.parindent", SILE.types.node.glue())
    SILE.settings:set("document.lskip", SILE.types.node.glue())
    SILE.settings:set("document.rskip", SILE.types.node.glue())
  end

  local class = SILE.documentState.documentClass

  -- Override itemize to suppress bullets and allow customizable spacing (scoped to this class).
  class:registerCommand("itemize", function (options, content)
    local sep = options.itemsep or SILE.scratch.hr_list.itemsep_default

    -- Save any existing class-level \item to restore after processing.
    local prevItem = nil
    if class._registeredCommands and class._registeredCommands["item"] then
      prevItem = class._registeredCommands["item"]
    end

    -- Temporarily override \item within this list only.
    class:registerCommand("item", function (opts, cont)
      _hr_noindent()
      SILE.process(cont)
      SILE.call("par")
      SILE.call("skip", { height = sep })
    end)

    SILE.process(content)

    -- Restore original \item definition on this class (or clear it).
    if prevItem then
      class:registerCommand("item", prevItem)
    elseif class._registeredCommands then
      class._registeredCommands["item"] = nil
    end
  end)
}

% JSON helper to load a file into a Lua table using a JSON library
\lua{
  function SILE.scratch.load_json_file(path)
    -- Allow local vendored libs if later added (sile/lib/?.lua)
    local added = "sile/lib/?.lua;"
    if not string.find(package.path, added, 1, true) then
      package.path = added .. package.path
    end

    local fh = io.open(path, "rb")
    if not fh then return nil, "open" end
    local content = fh:read("*a"); fh:close()

    -- Ensure a JSON library is available (lazy-init)
    local json = SILE.scratch.json
    if not json then
      local candidates = { "cjson.safe", "cjson", "dkjson", "json" }
      for _, name in ipairs(candidates) do
        local ok, mod = pcall(require, name)
        if ok and mod then
          json = mod
          SILE.scratch.json = mod
          SILE.scratch.json_lib = name
          break
        end
      end
    end
    if not json then return nil, "jsonlib" end

    local decode = json.decode or json.parse
    if not decode then return nil, "decode" end
    local ok, data = pcall(decode, content)
    if not ok or type(data) ~= "table" then return nil, "parse" end
    return data
  end
}

\define[command=sectionbox]{
  \skip[height=.7em,stretch=1fill]
  \hrulefill
  \skip[height=.7em,stretch=1fill]
  \process
  \skip[height=0pt,stretch=2in]
  \penalty[penalty=-500]
  \skip[height=0pt,stretch=-2in]
}

% Section box using typesetter:liner for per-line vertical gold rules.
% I've commented it out because it does not work aesthetically, and it's
% broken. But it is a beautiful idea, and I don't see anything like it
% documented elsewhere, so I'd like to push it up somewhere eventually
% maybe.
%\lua{
%  do
%    local class = SILE.documentState.documentClass
%
%    local function toNum(x)
%      if type(x) == "table" and x.tonumber then return x:tonumber() end
%      return x or 0
%    end
%
%    class:registerCommand("sectionbox", function (options, content)
%      local borderw = options.border or "0.8pt"
%      local color = options.color or "#c9b458"
%      local topGap = options.topgap or "0.35em"
%      local midGap = options.midgap or "0.4em"
%      local bottomGap = options.bottomgap or "0pt plus 3in"
%      local leftGap = options.leftgap or "-6pt"
%      local rightGap = options.rightgap or "-6pt"
%
%      SILE.call("skip", { height = topGap })
%
%      local ts = SILE.typesetter
%      local bw = toNum(SU.cast("length", borderw))
%      local lg = toNum(SU.cast("length", leftGap))
%      local rg = toNum(SU.cast("length", rightGap))
%
%      -- Track continuous vertical rules across glue by aggregating extents per page and section instance.
%      SILE.scratch.__sectionbox_state = SILE.scratch.__sectionbox_state or {}
%      SILE.scratch.__sectionbox_opts = SILE.scratch.__sectionbox_opts or {}
%      SILE.scratch.__sectionbox_uid = (SILE.scratch.__sectionbox_uid or 0) + 1
%      local uid = SILE.scratch.__sectionbox_uid
%      SILE.scratch.__sectionbox_opts[uid] = { color = color, bw = bw }
%      local function currentFolio()
%        local c = SILE.scratch and SILE.scratch.counters and SILE.scratch.counters.folio
%        return (c and c.value) or 1
%      end
%
%      local innerContent = function ()
%        local function goldOutsetHrule()
%          SILE.settings:temporarily(function ()
%            SILE.call("set", { parameter = "document.lskip", value = leftGap })
%            SILE.call("set", { parameter = "document.rskip", value = rightGap })
%            SILE.call("Gold", {}, function ()
%              SILE.call("hrule", { height = borderw, width = "100%lw" })
%            end)
%            SILE.call("par")
%          end)
%        end
%
%        goldOutsetHrule()
%        SILE.call("skip", { height = midGap })
%        SILE.process(content)
%        SILE.call("par")
%        goldOutsetHrule()
%      end
%
%      ts:liner("sectionbox", innerContent, function (self, typesetter, line)
%        local x = (typesetter.frame and typesetter.frame.state and typesetter.frame.state.cursorX) or 0
%        local y = (typesetter.frame and typesetter.frame.state and typesetter.frame.state.cursorY) or 0
%
%        local top = y-bw
%        local bottom = y
%        local f = typesetter.frame
%        local left = ((f and f.left and toNum(f:left())) or x) + lg
%        local right = ((f and f.right and toNum(f:right())) or x) - rg
%
%        -- Aggregate extents per page and draw a continuous rule spanning all intervening glue.
%        local folio = currentFolio()
%        local st = SILE.scratch.__sectionbox_state
%        st[folio] = st[folio] or {}
%        local bs = st[folio][uid]
%        if not bs then
%          bs = { xL = left, xR = right, yTop = top, yBottom = bottom }
%        else
%          if left < bs.xL then bs.xL = left end
%          if right > bs.xR then bs.xR = right end
%          if top < bs.yTop then bs.yTop = top end
%          if bottom > bs.yBottom then bs.yBottom = bottom end
%        end
%        st[folio][uid] = bs
%
%        -- Defer drawing to endPage; only aggregate extents here.
%
%        -- Output the actual line content
%        self:outputContent(typesetter, line)
%      end)
%
%      local bg = SU.cast("length", bottomGap)
%      SILE.call("skip", { height = bg })
%      SILE.call("penalty", { penalty = -500 })
%      SILE.call("skip", { height = -bg })
%    end)
%  end
%}
